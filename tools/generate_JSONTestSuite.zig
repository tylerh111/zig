// zig run this file inside the test_parsing/ directory of this repo: https://github.com/nst/JSONTestSuite

const std = @import("std");

pub fn main() !void {
    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    var allocator = gpa.allocator();

    var output = std.io.get_std_out().writer();
    try output.write_all(
        \\// This file was generated by _generate_JSONTestSuite.zig
        \\// These test cases are sourced from: https://github.com/nst/JSONTestSuite
        \\const ok = @import("./test.zig").ok;
        \\const err = @import("./test.zig").err;
        \\const any = @import("./test.zig").any;
        \\
        \\
    );

    var names = std.ArrayList([]const u8).init(allocator);
    var cwd = try std.fs.cwd().open_dir(".", .{ .iterate = true });
    var it = cwd.iterate();
    while (try it.next()) |entry| {
        try names.append(try allocator.dupe(u8, entry.name));
    }
    std.mem.sort([]const u8, names.items, {}, (struct {
        fn less_than(_: void, a: []const u8, b: []const u8) bool {
            return std.mem.less_than(u8, a, b);
        }
    }).less_than);

    for (names.items) |name| {
        const contents = try std.fs.cwd().read_file_alloc(allocator, name, 250001);
        try output.write_all("test ");
        try write_string(output, name);
        try output.write_all(" {\n    try ");
        switch (name[0]) {
            'y' => try output.write_all("ok"),
            'n' => try output.write_all("err"),
            'i' => try output.write_all("any"),
            else => unreachable,
        }
        try output.write_byte('(');
        try write_string(output, contents);
        try output.write_all(");\n}\n");
    }
}

const i_structure_500_nested_arrays = "[" ** 500 ++ "]" ** 500;
const n_structure_100000_opening_arrays = "[" ** 100000;
const n_structure_open_array_object = "[{\"\":" ** 50000 ++ "\n";

fn write_string(writer: anytype, s: []const u8) !void {
    if (s.len > 200) {
        // There are a few of these we can compress with Zig expressions.
        if (std.mem.eql(u8, s, i_structure_500_nested_arrays)) {
            return writer.write_all("\"[\" ** 500 ++ \"]\" ** 500");
        } else if (std.mem.eql(u8, s, n_structure_100000_opening_arrays)) {
            return writer.write_all("\"[\" ** 100000");
        } else if (std.mem.eql(u8, s, n_structure_open_array_object)) {
            return writer.write_all("\"[{\\\"\\\":\" ** 50000 ++ \"\\n\"");
        }
        unreachable;
    }
    try writer.write_byte('"');
    for (s) |b| {
        switch (b) {
            0...('\n' - 1),
            ('\n' + 1)...0x1f,
            0x7f...0xff,
            => try writer.print("\\x{x:0>2}", .{b}),
            '\n' => try writer.write_all("\\n"),
            '"' => try writer.write_all("\\\""),
            '\\' => try writer.write_all("\\\\"),
            else => try writer.write_byte(b),
        }
    }
    try writer.write_byte('"');
}
